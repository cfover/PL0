# PL0 编译器项目说明文档

## 项目概述

本项目是编译原理课程的经典实践作业——实现PL0语言的编译器及解释器。PL0语言是一种简单的程序设计语言，专为教学目的而设计，它包含了基本的数据类型、控制结构和程序结构，是理解编译器工作原理的理想范例。

### PL0语言特点

- 数据类型：仅支持无符号整数
- 变量声明：通过`var`关键字声明
- 常量定义：通过`const`关键字定义
- 控制结构：支持`if`条件语句和`while`循环语句
- 过程定义：通过`procedure`关键字定义过程

### 编译器组成

本PL0编译器实现了以下核心功能模块：

1. **词法分析器（Lexer）**：将源代码转换为token序列
2. **语法分析器（Parser）**：根据语法规则构建语法树并进行语法检查
3. **代码生成器**：生成中间代码
4. **解释器（Interpreter）**：执行生成的中间代码


### 文件结构

```
PL0/
├── pl0.c             # 主程序文件，包含编译器和解释器实现
├── pl0.h             # 头文件，定义数据结构和常量
├── set.h             # 符号集合相关头文件
└── set1.h            # 符号集合实现
```

### 编译方法

#### Windows系统编译方法

**方法一：使用Visual Studio创建新项目**
1. 打开Visual Studio
2. 选择"创建新项目" > "空项目" > "下一步" > 输入项目名称 > "创建"
3. 在"解决方案资源管理器"中，右键点击"源文件" > "添加" > "现有项"
4. 选择项目目录中的`pl0.c`和`set1.h`文件
5. 右键点击"头文件" > "添加" > "现有项"，选择`pl0.h`和`set.h`文件
6. 点击编译按钮或使用快捷键`Ctrl+Shift+B`编译项目

**方法二：使用命令行（MinGW/GCC）**
1. 确保已安装MinGW或其他兼容的C编译器
2. 打开命令提示符，进入PL0项目目录
3. 执行以下命令：
   ```
   gcc -o pl0 pl0.c -Wall -Wextra
   ```

#### Linux/Mac系统编译方法

1. 确保已安装GCC编译器
2. 打开终端，进入PL0项目目录
3. 执行以下命令：
   ```
   gcc -o pl0 pl0.c -Wall -Wextra
   ```

### 运行方法

编译成功后，可以通过以下方式运行PL0编译器：

```
./pl0  # Linux/macOS
pl0.exe  # Windows
```

然后根据提示输入PL0源程序文件路径。

## 使用指南

### 基本使用流程
1. 准备一个遵循PL0语法规则的源程序，扩展名为`.pl0`或`.txt`
2. 编译PL0编译器
3. 运行编译器并输入源程序文件名
4. 查看编译结果

### PL0语言语法要点

PL0编译器对语法要求非常严格，请特别注意以下几点：
1. 赋值操作符使用`:=`而非`=`
2. 不等于运算符使用`<>`而非`!=`
3. 变量名和过程名不能与保留字相同
4. 每条语句后必须有分号（`;`）
5. 程序必须以句点（`.`）结束

### 完整的语法产生式
1. 程序入口
```bnf
<程序> → program <标识符> ; <声明部分> <语句> .
```
2. 声明部分（变量声明 + 过程声明）
```bnf
<声明部分> → [ <变量声明> ] { <过程声明> }
<变量声明> → var <标识符表> ;
<标识符表> → <标识符> { , <标识符> }
<过程声明> → procedure <标识符> ; <声明部分> <语句> ;
```

3. 语句（核心执行逻辑）
```bnf
<语句> → <赋值语句> 
        | <条件语句> 
        | <循环语句> 
        | <过程调用语句> 
        | <复合语句>  
        | <空语句>  // 无操作语句（如单独的;）

<赋值语句> → <标识符> := <表达式>
<条件语句> → if <条件> then <语句> [ else <语句> ]
<循环语句> → while <条件> do <语句>
<过程调用语句> → call <标识符>
<复合语句> → begin <语句> { ; <语句> } end
<空语句> → ε  // ε 表示“空”，如过程内无语句时可用
```

4. 条件（布尔表达式，用于 if/while）
```bnf
<条件> → odd <表达式>  // 判奇：表达式结果为奇数则条件为真
        | <表达式> <关系运算符> <表达式>

<关系运算符> → = | <> | < | <= | > | >=
```

5. 表达式（算术表达式，支持加减乘除和优先级）
```bnf
<表达式> → [ + | - ] <项> { <加减运算符> <项> }
<项> → <因子> { <乘除运算符> <因子> }
<因子> → <标识符> | <常数> | ( <表达式> )

<加减运算符> → + | -
<乘除运算符> → * | /
```

6.基础元素（标识符、常数）
```bnf
<标识符> → <字母> { <字母> | <数字> }
<常数> → <数字> { <数字> }
<字母> → a | b | ... | z | A | B | ... | Z  // 大小写不敏感（多数实现）
<数字> → 0 | 1 | ... | 9
```

### 正确的示例程序

我们已经创建了一个名为`example.pl0`的示例程序，它严格遵循PL0语法规则：

```pl0
const n=10;
var i,sum;
procedure example;
begin
  i:=1;
  sum:=0;
  while i<=n do
    begin
      sum:=sum+i;
      i:=i+1
    end;
  if sum=55 then
    begin
      i:=sum
    end
end;
begin
  call example
end.
```


### 常见错误及解决方案

1. **语法错误**：仔细检查程序语法，特别是赋值操作符（`:=`）和结束符（`.`）
2. **未定义标识符**：确保所有使用的变量都在`var`部分声明
3. **保留字使用错误**：不要使用`begin`、`end`、`if`等保留字作为变量名
4. **缺少分号**：确保每条语句后都有分号
5. **文件路径问题**：确保输入正确的文件名，最好将源程序放在与编译器相同的目录下

### 验证编译成功

编译成功后，你将看到以下输出内容：

1. **源代码行号和内容**：编译器会显示源代码内容及其对应的行号
2. **中间代码**：以表格形式显示生成的中间代码，每行包含指令索引、指令类型和操作数
3. **运行时输出**：在执行程序时，编译器会显示以下内容：
   - "Begin executing PL/0 program." - 程序开始执行
   - 一系列数字输出 - 这些是变量赋值操作的值（由STO指令产生）
   - "End executing PL/0 program." - 程序执行结束
4. **完整代码列表**：最后会显示完整的中间代码列表

#### 运行时输出说明

在PL0解释器中，每当执行STO（存储）指令时，都会自动打印出被存储的值。这就是我们看到的一系列数字输出。例如，在计算1到10之和的程序中：

```
Begin executing PL/0 program.
1  // i:=1 的值
0  // sum:=0 的值
1  // i的值
2  // i:=i+1的值
3  // sum:=sum+i的值
3  // i的值
6  // sum:=sum+i的值
...
55 // 最终sum的值
End executing PL/0 program.
```

这些数字输出实际上是PL0解释器的一个调试特性，帮助用户了解程序执行过程中的变量值变化。在实际应用中，可以通过观察这些输出来验证程序的执行逻辑是否正确。

如果出现错误，请根据错误提示检查并修改源程序。

### 错误处理

编译器会在以下情况报告错误：
- 词法错误：无法识别的字符或符号
- 语法错误：不符合PL0语法规则
- 语义错误：如变量未定义、类型不匹配等

错误信息会显示错误位置和错误类型，帮助用户定位和修复问题。

## 代码结构详解

### 核心数据结构

- **符号表项（table）**：用于存储标识符（变量、常量、过程）的信息
- **指令（instruction）**：中间代码指令的结构
- **符号集合（symset）**：用于语法分析中的符号跟踪
  
### 关于set1.h的说明

`set1.h`是PL0编译器中一个特殊的头文件，它不仅包含了声明，还包含了实现代码。在PL0实现中，`set1.h`负责提供符号集合的操作实现，包括：

- **符号集合的创建**：通过`createset()`函数创建符号集合
- **集合操作**：如集合的合并（`uniteset()`）
- **元素查询**：通过`inset()`函数检查元素是否在集合中
- **内存管理**：通过`destroyset()`函数释放集合内存

在语法分析过程中，符号集合用于跟踪期望的语法符号，确保程序结构符合PL0语言的语法规则。例如，当解析表达式时，编译器需要知道在当前位置哪些符号是合法的。

虽然在现代C编程实践中，通常将声明放在.h文件而将实现放在.c文件中，但PL0作为教学代码，将实现放在头文件中简化了项目结构，更便于理解整体框架。

### 主要函数

1. **getsym()**：词法分析函数，读取下一个符号
2. **error(n)**：错误处理函数，报告第n种错误
3. **gen(op, lev, adr)**：代码生成函数，生成一条中间代码指令
4. **interpret()**：解释执行生成的中间代码
5. **block()**：程序块分析函数，处理变量声明、常量定义和过程定义
6. **statement()**：语句分析函数
7. **expression()**：表达式分析函数
8. **term()**：项分析函数
9. **factor()**：因子分析函数

### 中间代码指令集

PL0编译器生成的中间代码包含以下几种指令类型：

- **LIT**：将常量值取到栈顶
- **OPR**：执行算术或逻辑运算
- **LOD**：将变量值加载到栈顶
- **STO**：将栈顶值存入变量
- **CAL**：调用过程
- **INT**：为被调用的过程分配栈空间
- **JMP**：无条件跳转
- **JPC**：条件跳转
- **RET**：过程返回
- **RED**：读取输入到变量
- **WRT**：将栈顶值输出

## 扩展任务

完成基本功能后，你可以尝试以下扩展任务来加深对编译原理的理解：

### 基础扩展任务
1. **添加单目运算符**
   - 添加负号（-）运算符
   - 添加逻辑非（!）运算符

2. **添加复合赋值运算符**
   - 添加加等于（+=）、减等于（-=）、乘等于（*=）、除等于（/=）等运算符

3. **添加其他运算符**
   - 添加模运算（%）
   - 添加位运算（&、|、^）

4. **添加break和continue语句**
   
   - 实现break语句用于跳出循环
   - 实现continue语句用于跳过当前循环迭代
   
5. **改进输入输出格式**
   - 修改STO指令，使其在输出时不再自动打印变量值
   - 添加专门的write指令，用于输出变量值

6. **添加程序行号和错误位置信息**
   - 为每个指令添加行号，用于调试时的指令跟踪
   - 在错误报告中包含具体的行号和列号，方便定位问题

7. **支持命令行参数**
   - 允许用户在命令行中指定输入文件和输出文件
   - 实现编译选项，如优化等级、调试信息等

8. **添加常量表达式计算优化**
   - 当表达式中只包含常量时，在编译时计算结果，避免运行时计算，如`2+3`在编译时直接替换为`5`

9. **支持命名常量表达式**
   - 允许在const声明中使用已经定义的常量（如 const a=5, b=a+3; ）

10. **实现注释功能**

       - 实现行注释（如`// 这是注释`）

       - 实现块注释（如`/* 这是多行注释 */`）
         
11. **实现else分支**

       - 实现if-then-else条件判断语句





### 进阶扩展任务
1. **添加逻辑运算符**
    - 逻辑与（&&）和逻辑或（||）运算符
    - 支持短路操作

2. **实现函数和递归调用**
   - 允许函数有返回值
   - 支持函数调用表达式(将返回值放入表达式)

3. **添加循环控制语句**
   - 添加do-while循环语句
   - 添加for循环语句

4. **添加跳转语句**
   - 添加goto语句，能够跳转到指定标签
   - 添加label(标签)语句

5. **添加简单的字符串处理功能**
   - 实现字符串常量
   - 添加字符串连接等基本操作
   - 扩展write语句支持字符串输出

6. **增强输入输出功能**
   - 添加格式化输出功能
   - 添加文件输入输出支持

7. **添加数组数据结构支持**
   - 实现一维数组的定义和访问
   - *添加数组边界检查

8. **修改赋值语句**
   - 将赋值符号从':='替换为'='
   - 支持多个变量赋值（赋值表达式为右值），如`a=b=1`
   - 增加‘==’运算符，用于比较两个变量是否相等



## 作业要求

1. 理解并分析现有的PL0编译器代码
2. 编写测试程序验证编译器的正确性
3. 至少完成4项基础扩展任务和2项进阶扩展任务
4. 撰写详细的实验报告，包括设计思路、实现细节和测试结果

## 参考资源

- 《编译原理》（Alfred V. Aho等著）
- 《PL/0编译程序设计》相关文档
- 编译原理课程讲义

## 常见问题解答

1. **问题**：如何处理源程序中的错误？
   **解答**：编译器会在遇到错误时输出错误信息，但会尝试继续编译以发现更多错误。错误信息包含错误类型和位置。

2. **问题**：如何调试PL0程序？
   **解答**：可以在解释器中添加调试输出，观察程序执行过程中的栈状态和变量值变化。

3. **问题**：扩展功能时应该注意什么？

   **解答**：扩展功能时需要同时修改词法分析器、语法分析器和代码生成器，确保它们协调工作。建议先详细设计，再逐步实现和测试。
